# -*- coding: utf-8 -*-
"""AETG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1se5cHoEpEIFdNvffQS_sTJk7byFxVd-f
"""

from google.colab import drive

drive.mount('/content/gdrive/')

"""上面这一行代码用于关联服务器和用户自己的google drive文档，本程序要读取的文件均在google drive上"""

'''
This module implements AETG algorithm.
A file of factors and values is needed as input.
The format of the file is in ReadMe.md
Input of the program is the route of the above file and t, since we are generating a t-way combination testing cases.
Output is a csv file in the current working directory, describing all testing cases generated.
Have fun!
By the way, you may want to put this code on a stronger machine since it requires a certain amount of memory and cpu time
'''
import random
import os
import time
import pickle
os.chdir(os.path.join(os.getcwd(),r'gdrive/My Drive/Colab Notebooks/'))
#要更改系统工作目录请修改上一句代码

"""路径要求：<br>
供测试的因子应该位于./,名为test.txt,编码为utf-8，文件内容形式如下<br><br>
![temp.png](data:image/png;base64,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)
<br>
./路径下有AETG_temp文件夹，用于存储计算的中间结果<br>
生成的testCase输出在./result.csv中，编码为utf-8
要自定义文件以及路径请修改下面代码中的filepath变量的值
"""

def DFS(t, next_index, factor, current_list, uncoverTuple):
    if len(current_list) == t:
        uncoverTuple.append({'con': current_list.copy(), 'covered': False})
        for ele in current_list:
            factor[ele['index']]['situation'][1][ele['column']] += 1
        return
    if next_index >= len(factor):
        return
    for i in range(next_index, len(factor)):
        # big cycle
        # heading factor from factor[next_index] to factor[last]
        for j, value in enumerate(list(factor[i].values())[1][0]):
            current_list.append({'index': i, 'value': value, 'column': j})
            DFS(t, i + 1, factor, current_list, uncoverTuple)
            current_list.pop()
'''
上面的DFS函数用于生成所有可能的t-way combination
'''

def initial(t, factor, uncoverTuple):
    current_list = []
    DFS(t, 0, factor, current_list, uncoverTuple)


def DFS2(case_value, combin, dim, next_index, current_list):
    if len(current_list) == dim:
        combin.append(current_list.copy())
        return
    for i in range(next_index, len(case_value)):
        current_list.append(case_value[i].copy())
        DFS2(case_value, combin, dim, i + 1, current_list)
        current_list.pop()

'''
DFS2和DFS3，在构建某一个testCase时，我们需要有已经选定的所有value能构成的所有t-way combination，这两个函数用于向数据结构中添加所有的t-way combination
'''
def DFS3(case_value, combin, dim, next_index, current_list, order):
    if len(current_list) == dim:
        combin.append(current_list.copy())
        return
    for i in range(next_index, len(case_value)):
        current_list.append(case_value[i].copy())
        DFS3(case_value, combin, dim, i + 1, current_list, order)
        current_list.pop()


'''
This function tries to list all (t-1)-way combinations out of an array with at least t-1 eles
'''
def listCombination(case_value, dim, order=None):
    combin = []
    current_list = []
    if order is None:
        DFS2(case_value, combin, dim, 0, current_list)
    else:
        DFS3(case_value, combin, dim, 0, current_list, order)
    return combin


def testUncover(case_value, work, t, factor):
    if len(case_value) < t:
        '''
        case_value[]
        ele: 
        [
        {'value':...,'index':...,'column':...},
        {'value':...,'index':...,'column':...},
        ]
        注意，combin的元素size比work中的元素size小
        work[]
        ele:
        [
        {'value':...,'index':...,'column':...},
        {'value':...,'index':...,'column':...},
        {'value':...,'index':...,'column':...},
        ]
        '''
        counter = 0
        for each_uncovered in work:
            flag = True
            for each in case_value:
                if not flag:
                    break
                if each not in each_uncovered['con']:
                    flag = False
                    break
            counter = counter + 1 if flag else counter
        return counter

    else:
        counter = 0
        li = case_value.copy()
        last = li.pop()
        combination = listCombination(li, t - 1)

        '''
        是counter少了，不是combination少了？
        是conbination少了。
        '''

        # gives
        for i in range(len(combination)):
            combination[i].append(last)
        '''
        combination[]
        ele: 
        [
        {'value':...,'index':...,'column':...},
        {'value':...,'index':...,'column':...},
        {'value':...,'index':...,'column':...}
        ]
        
        work[]
        ele:
        [
        {'value':...,'index':...,'column':...},
        {'value':...,'index':...,'column':...},
        {'value':...,'index':...,'column':...},
        ]
        '''
        for each in combination:
            for each_uncovered in work:
                flag = True
                for each_dic in each:
                    if each_dic not in each_uncovered['con']:
                        flag = False
                        break
                counter = counter + 1 if flag else counter
        return counter


# 在构建每一个testCase时，对于factor_0 - factor_n， 此函数找出对于某一个特定的factor_i的所有可供取值的value中，最好的一个——即取了它之后能够保证覆盖最多的组合
def searchValue(t, factor, uncoverTuple, f_index, case_value, last_cover):
    bestValue = 0
    most_uncover = 0
    for i, value in enumerate(factor[f_index]['situation'][0]):
        # test each attribute in this factor
        case_value.append({'value': value, 'index': f_index, 'column': i})
        work = uncoverTuple.copy()
        this_uncover = testUncover(case_value, work, t, factor)
        if this_uncover > most_uncover or (this_uncover == 0 and most_uncover == 0):
            # when both are 0 we still record a value
            most_uncover = this_uncover
            bestValue = value
        case_value.pop()
    if len(case_value) >= t:
        most_uncover += last_cover
    return bestValue, most_uncover


# 此函数用于生成M个case，并返回最好的一个testCase以及它所覆盖的组合个数
# 在添加一个testCase（n个value的元组）的过程中，被添加上去的testCase是从M个testCase中选的最好的一个。
def generateMcase(M, t, factor, uncoverTuple):
    Permuted = []
    BestCase = None
    case_value = []
    cover_new = 0
    # order = None
    '''
    Step 1: select f_1
    Do this once is enough
    '''
    max_cover = 0
    factor_index = 0
    value_index = 0

    find_array = [i for i in range(len(factor))]
    random.shuffle(find_array)
    # 随机将factor的数组排序，保证当有多个factor候选时，不会因为某一个factor排在前面而且不能提供有效的更新时，导致程序卡死
    for i in range(len(find_array)):
        ele = factor[i]
        # iterate the whole factor dictionary
        # find the value v_i for factor_i which makes most uncovered t-way combinations.
        if max(ele['situation'][1]) > max_cover:
            max_cover = max(ele['situation'][1])
            factor_index = i
            value_index = ele['situation'][1].index(max_cover)
    Permuted.append(factor_index)
    case_value.append(
        {'value': factor[factor_index]['situation'][0][value_index], 'index': factor_index, 'column': value_index})
    origin = case_value.copy()
    for i in range(M):
        if (i + 1) % 10 == 0 or i == 0:
            print(f'I = {i + 1} \t', end='')
        '''
        Step 2
        Permute f_2 ~ f_k
        '''
        temp = [j for j in range(len(factor))]
        temp.remove(factor_index)
        random.shuffle(temp)
        Permuted.extend(temp)
        case_value = origin.copy()
        last_cover = None
        '''
        Step 3
        pick values for f_2 ~ f_k
        '''
        for index in range(1, len(factor)):
            picked_value, cover_new = searchValue(t, factor, uncoverTuple, Permuted[index], case_value, last_cover)
            # if value returned is 0,0
            # then we know this permutation is
            last_cover = cover_new
            case_value.append({'value': picked_value, 'index': Permuted[index],
                               'column': factor[Permuted[index]]['situation'][0].index(picked_value)})
            # pick a value from f_2 to f_k
        if BestCase is not None and BestCase['cover_new'] > cover_new:
            continue
        else:
            if BestCase is None:
                BestCase = {'case': case_value.copy(), 'cover_new': cover_new}
                # order = Permuted.copy()
            if BestCase['cover_new'] < cover_new:
                BestCase['case'] = case_value.copy()
                BestCase['cover_new'] = cover_new
                # order = Permuted.copy()
    print()
    return case_value, cover_new

# 选出一个testCase后，要更新未被覆盖的组合的集合
def updateUncover(uncoverTuple, candidate, dim, factor):
    all_combins = listCombination(candidate, dim, True)
    '''    
    uncoverTuple is a set
    each ele is a dictionary
    {'con':[],'covered':false}
    ele in 'con'
    [
      {'index':...,'value':...,'column':...},
      {'index':...,'value':...,'column':...},
      {'index':...,'value':...,'column':...}
    ]
    
    all_combins:  []
    ele in all_combins:
    [
        {'index':...,'value':...,'column':...},
        {'index':...,'value':...,'column':...},
        {'index':...,'value':...,'column':...}
    ]
    '''
    counter = 0
    for each in uncoverTuple:
        # {'con':...,'covered':...}
        if each['covered']:
            continue
        for each_ele in all_combins:
            # [  {'index':...,'value':...,'column':...},{},{}]
            flag = True
            if not flag:
                break
            for each_dic in each_ele:
                # {}
                flag = False if each_dic not in each['con'] else flag
                if not flag:
                    break
            if flag:
                counter += 1
                uncoverTuple.remove(each)
                for each_dic in each_ele:
                    factor[each_dic['index']]['situation'][1][each_dic['column']] -= 1

    return counter

# 此函数用于输出程序生成的结果到csv中
def out(testcase, factor):
    factor_list = [i['name'] for i in factor]
    with open(r'./result.csv', encoding='utf8', mode='w') as f:
        for i, data in enumerate(factor_list):
            f.write(str(data) + ',')
        f.write('覆盖组合个数\n')
        for each_case in testcase:
            temp_list = [i for i in range(len(factor))]
            for each_dictionary in each_case['case']:
                temp_list[each_dictionary['index']] = str(each_dictionary['value']) + ','
            temp_list.append(str(each_case['cover']) + '\n')
            for each in temp_list:
                f.write(each)

# 以下两个函数用于将计算的中间结果序列化和反序列化
# 白嫖版google colab一次性使用时间最长是12h，而完成一次计算需要43h，因此要在笔记本资源被回收之间将中间结果写到文件中。
def store(time_cost,  uncoverTuple, testCase, factor):
    with open(r'./AETG_temp/time.bin', 'wb') as f:
        pickle.dump(time_cost, f, 1)
    # with open(r'./newCover.bin', 'wb')as f:
    #     pickle.dump(newCover, f, 1)
    with open(r'./AETG_temp/uncoverTuple.bin', 'wb') as f:
        pickle.dump(uncoverTuple, f, 1)
    with open(r'./AETG_temp/testCase.bin', 'wb') as f:
        pickle.dump(testCase, f, 1)
    with open(f'./AETG_temp/factor.bin', 'wb') as f:
        pickle.dump(factor, f, 1)


def restore():
    time_cost, uncoverTuple, testCase, factor = None, None, None, None
    with open(r'./AETG_temp/time.bin', 'rb') as f:
        time_cost = pickle.load(f)
    # with open(r'./newCover.bin', 'rb')as f:
    #     newCover = pickle.load(f)
    with open(r'./AETG_temp/uncoverTuple.bin', 'rb') as f:
        uncoverTuple = pickle.load(f)
    with open(r'./AETG_temp/testCase.bin', 'rb') as f:
        testCase = pickle.load(f)
    with open(f'./AETG_temp/factor.bin', 'rb') as f:
        factor = pickle.load(f)
    return time_cost,uncoverTuple,testCase,factor

#这段代码一定要跑，用于初始化必需的参数
uncoverTuple = []
testCase = []
factor = []
M = 50
last=0
t = 3
# 修改参数 t 可以以t-way combination生成testCase，理论上支持所有大于1的自然数
filePath = r'./problem2_factor.txt'
# 这个路径是装着factor的文件的路径，可以自行修改
batch_time=float(input('Give running hours:'))
# 输入此次计算的预定时间，笔记本将会在时间到达后将中间结果写到文件中去，并且自动停止。

"""* Choose to initial or reload

"""

# 因为是白嫖的colab，每计算12小时笔记本的资源会被回收。
# 每12小时要保存一次中间结果，然后重新连接，读回中间结果，继续计算
# 将数据结构序列化到文件中，重新上线后再反序列化 ok
# 计算的代码相同，只要保证重装数据的改变对计算代码透明
'''
while 第一句之前，先判断是不是应该停了。
如果跑到了十一个半小时，那么
将uncoverTuple,testCase,newCover,factor,M,t,total(total-time.time()+last)
全部序列化出去

恢复：
last=total.deser
M,t,newCover = deser
uncoverTuple,testCase = derser
重做函数定义
重新import
重新定位到文件夹
total=time.time()
重新开始计算

seralize(...)
deseralize(...)
'''

# initial code: only run once.
# 只有第一次运行时才会跑这一段代码，如果是要接着上一次计算结果，请跑下一段代码。
with open(filePath, encoding='utf8') as f:
    temp = [i.strip(' \t\n').split(',') for i in f]
    for i, each in enumerate(temp):
        temp[i][0:1] = each[0].split(':')
    for i, each in enumerate(temp):
        factor.append({'name': temp[i][0], 'situation': [temp[i][1:], [0 for i in range(len(temp[i]) - 1)]]})
initial(t, factor, uncoverTuple)
print(f'Finish initialization, size of uncoverTuple: {len(uncoverTuple)}')

# 将文件中的数据结构重新load回来，恢复状态。
last, uncoverTuple, testCase, factor = restore()
print(f'trained_hours_accumulated = {last/3600}')
print("uncoverTuple.size() = ",len(uncoverTuple))
print("testCase.size() = ",len(testCase))
print(f"Next calculation period : {batch_time}hour(s)")

# 计算用代码
total=time.time()
while (len(uncoverTuple)):
    if  (time.time()-total)/3600>batch_time:
        store(last+time.time()-total,uncoverTuple,testCase,factor)
        break
    # tempp=time.time()-total
    # store(tempp,uncoverTuple,testCase,factor)
    # temp1,temp3,temp4,temp5 = restore()
    # print(f'After restore: timeCost:{tempp==temp1}\nuncoverTuple:{ uncoverTuple == temp3}\ntestCase:{testCase == temp4}\nfactor:{factor == temp5}')
    print('Searching for M cases :\t', end='')
    timer = time.time()
    candidate, newCover = generateMcase(M, t, factor, uncoverTuple)
    '''for each in uncoverTuple:
          if  each['covered']:
              print(each['con'])'''
    print('Searching finished, time costs = %2.5fs\t' % (time.time() - timer), end='')
    if newCover:
        updateUncover(uncoverTuple, candidate, t, factor)
        testCase.append({'case': candidate, 'cover': newCover})
        print(f'Size of testCase:{len(testCase)}, uncoveredTuple: {len(uncoverTuple)}')
    else:
        print('This search gives no update.')

out(testCase, factor)
if len(uncoverTuple) == 0:
  print('Algorithm finished, total time costs = %2.3fh' % ((time.time() - total+last) / 3600)) 
else :
  print('Task temporarily done, time costs = %2.3fh' % ((time.time() - total+last) / 3600))
print('Finish writing results to ./result.rsv')

'''
When you want to stop calculating before the ddl you set, stop the code block above and run this line immediately.
'''
store(last+time.time()-total,uncoverTuple,testCase,factor)